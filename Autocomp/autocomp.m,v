head	1.1;
access;
symbols;
locks
	lisiecki:1.1; strict;
comment	@// @;


1.1
date	2003.12.06.21.11.38;	author lisiecki;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@function varargout = autocomp(varargin)
% AUTOCOMP Application M-file for autocomp.fig
%    FIG = AUTOCOMP launch autocomp GUI.
%    AUTOCOMP('callback_name', ...) invoke the named callback.

% Last Modified by GUIDE v2.0 25-Aug-2003 16:45:00

if nargin == 0  % LAUNCH GUI

	fig = openfig(mfilename,'reuse');
    disp(' ')
    disp('Welcome to the Automated Compositing Tool.')
    disp('Created by Lorraine Lisiecki, 2003, with funding from')
    disp('a Schlanger Ocean Drilling Fellowship (NSF-USSSP).')
    disp(' ')

	% Use system color scheme for figure:
	set(fig,'Color',get(0,'defaultUicontrolBackgroundColor'));

	% Generate a structure of handles to pass to callbacks, and store it. 
	handles = guihandles(fig);
    handles.offset=0;
    handles.color=[];
    handles.comp=[];
    handles.cds=[];
    handles.tie=[];
    handles.table=[];
    handles.section=[];

	guidata(fig, handles);

	if nargout > 0
		varargout{1} = fig;
	end

elseif ischar(varargin{1}) % INVOKE NAMED SUBFUNCTION OR CALLBACK

	try
		[varargout{1:nargout}] = feval(varargin{:}); % FEVAL switchyard
	catch
		disp(lasterr);
	end

end


%| ABOUT CALLBACKS:
%| GUIDE automatically appends subfunction prototypes to this file, and 
%| sets objects' callback properties to call them through the FEVAL 
%| switchyard above. This comment describes that mechanism.
%|
%| Each callback subfunction declaration has the following form:
%| <SUBFUNCTION_NAME>(H, EVENTDATA, HANDLES, VARARGIN)
%|
%| The subfunction name is composed using the object's Tag and the 
%| callback type separated by '_', e.g. 'slider2_Callback',
%| 'figure1_CloseRequestFcn', 'axis1_ButtondownFcn'.
%|
%| H is the callback object's handle (obtained using GCBO).
%|
%| EVENTDATA is empty, but reserved for future use.
%|
%| HANDLES is a structure containing handles of components in GUI using
%| tags as fieldnames, e.g. handles.figure1, handles.slider2. This
%| structure is created at GUI startup using GUIHANDLES and stored in
%| the figure's application data using GUIDATA. A copy of the structure
%| is passed to each callback.  You can store additional information in
%| this structure at GUI startup, and you can change the structure
%| during callbacks.  Call guidata(h, handles) after changing your
%| copy to replace the stored original so that subsequent callbacks see
%| the updates. Type "help guihandles" and "help guidata" for more
%| information.
%|
%| VARARGIN contains any extra arguments you have passed to the
%| callback. Specify the extra arguments by editing the callback
%| property in the inspector. By default, GUIDE sets the property to:
%| <MFILENAME>('<SUBFUNCTION_NAME>', gcbo, [], guidata(gcbo))
%| Add any extra arguments after the last argument, before the final
%| closing parenthesis.

% --------------------------------------------------------------------
function varargout = sig1_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.sig1.
% --------------------------------------------------------------------
function varargout = sig2_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.sig2.
set(handles.msig2,'String',[get(handles.sig2,'String') '.new']);
% --------------------------------------------------------------------
function varargout = sig3_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.sig3.
set(handles.msig3,'String',[get(handles.sig3,'String') '.new']);
% --------------------------------------------------------------------
function varargout = sig4_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.sig4.
set(handles.msig4,'String',[get(handles.sig4,'String') '.new']);

% --------------------------------------------------------------------
function varargout = msig2_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.msig2.
% --------------------------------------------------------------------
function varargout = msig3_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.msig3.
% --------------------------------------------------------------------
function varargout = msig4_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.msig4.

% --------------------------------------------------------------------
function varargout = match2_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.match2.
[p,n,e,v]=fileparts(get(handles.match2,'String'));
if(~isempty(n) & isempty(e))
    set(handles.match2,'String',[get(handles.match2,'String') '.match']);
end
% --------------------------------------------------------------------
function varargout = match3_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.match3.
[p,n,e,v]=fileparts(get(handles.match3,'String'));
if(~isempty(n) & isempty(e))
    set(handles.match3,'String',[get(handles.match3,'String') '.match']);
end
% --------------------------------------------------------------------
function varargout = match4_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.match4.
[p,n,e,v]=fileparts(get(handles.match4,'String'));
if(~isempty(n) & isempty(e))
    set(handles.match4,'String',[get(handles.match4,'String') '.match']);
end

% --------------------------------------------------------------------
function varargout = cdsname_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.cdsname.
% --------------------------------------------------------------------
function varargout = name1_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.name1.
% --------------------------------------------------------------------
function varargout = name2_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.name2.
% --------------------------------------------------------------------
function varargout = name3_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.name3.
% --------------------------------------------------------------------
function varargout = name4_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.name4.


% --------------------------------------------------------------------
function varargout = slider1_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.slider1.
y=ylim(handles.axes1);
v=get(handles.slider1,'Value');
maxv=get(handles.slider1,'Max');
step=y(1)-(maxv-v);
ylim(handles.axes1, [y(1)-step y(2)-step]);
ylim(handles.axes2, [y(1)-step y(2)-step]);
%xlim(handles.axes1,'auto');

% --------------------------------------------------------------------
function varargout = create_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.create.
if(isempty(get(handles.sig1,'String')))
    disp('Error: No target signal')
    break
else
    hole{1}=load(get(handles.sig1,'String'));
    mhole{1}=hole{1};
    match{1}=hole{1};
    match{1}(:,3:4)=match{1}(:,1:2);
end
if(isempty(get(handles.sig2,'String')))
    disp('Error: No additional signal')
    break
end
s=[];
for i=2:4
    sig=['get(handles.sig' num2str(i) ',''String'')'];
    if(~isempty(eval(sig)))
        msig=['get(handles.msig' num2str(i) ',''String'')'];
        if(isempty(eval(msig)))
            s=['Error: No matching signal for', get(['handles.sig' num2str(i)],'String')];
            disp(s)
        end
        m=['get(handles.match' num2str(i) ',''String'')'];
        if(isempty(eval(m)))
            s=['Error: No match file for', get(['handles.sig' num2str(i)],'String')];
            disp(s)
        end
        if(isempty(s))
            hole{end+1}=load(eval(sig),'-ASCII');
            mhole{end+1}=load(eval(msig),'-ASCII');
            match{end+1}=load(eval(m),'-ASCII');
        end
    end
end
num=max(size(hole));
step=str2num(get(handles.step,'String'));

d=min(mhole{1}(:,2));
c=mhole{1}(1,1);
comp=[];
dmax=max(mhole{1}(:,2));

while(d+step<=max(mhole{1}(:,2)))
    i=find(mhole{1}(:,1)==c);
    if(max(mhole{1}(i,2))<d & mhole{1}(i(end)+1,2)<=d);
        i=max(find(mhole{1}(:,2)<=d));
        c=mhole{1}(i,1);
        new_hole=1;
    else
        i=max(find(mhole{1}(i,2)<=d));
        new_hole=0;  
    end
    
    d2=d+step;
    i2=min(find(mhole{1}(:,2)>=d2 & mhole{1}(:,1)==c));
    if(isempty(i2))
        i2=min(find(mhole{1}(:,2)>=d2));
    end
    c2=mhole{1}(i2,1);
    my=[];
    new_d=[];
    
    for j=1:num
        valid(j)=1;
        edge(j)=0;
        score(j)=10;
        mci=find(match{j}(:,3)==c | match{j}(:,3)==c2);
        mi1_less=max(find(match{j}(mci,4)<=d & match{j}(mci,3)==c));
        mi1_more=min(find(match{j}(mci,4)>d & match{j}(mci,3)==c));
        mi2_less=max(find(match{j}(mci,4)<=d2 & match{j}(mci,3)==c2));
        mi2_more=min(find(match{j}(mci,4)>d2 & match{j}(mci,3)==c2));
        if(~isempty(mi1_less) & (isempty(mi1_more)| mi1_more<=mi1_less))
            %mi1_less
            mi1_more=min(find(match{j}(mci,4)>d & mci>mi1_less));
        end
        if(isempty(mi2_less))
            mi2_less=max(find(match{j}(mci,4)<=d2));
        end
        if(~isempty(mi2_less) & (isempty(mi2_more)| mi2_more<=mi2_less))
            mi2_more=min(find(match{j}(mci,4)>d2 & mci>mi2_less));
        end
        
        if(isempty(mi1_less) | isempty(mi1_more) | isempty(mi2_less) | isempty(mi2_more))
            valid(j)=0;
            if(j==1);
                mdj(j)=d;
                md2j(j)=d2;
                mc(j)=match{j}(mci(mi1_less),1);
            end
            
        elseif(match{j}(mci(mi1_less),1)~=match{j}(mci(mi1_more),1) | ...
                match{j}(mci(mi2_less),1)~=match{j}(mci(mi2_more),1) | ...
                match{j}(mci(mi1_less),1)~=match{j}(mci(mi2_less),1))
            valid(j)=0;
            if(j==1);
                mdj(j)=d;
                md2j(j)=d2;
                mc(j)=match{j}(mci(mi1_less),1);
            end
            
        else
            %[mi1_less mi1_more  mi2_less mi2_more]
            %[d c d2 c2 j]
            sub=match{j}(mci(mi1_less:mi1_more),:);
            md=interp1(sub(:,4),sub(:,2),d);
            sub=match{j}(mci(mi2_less:mi2_more),:);
            md2=interp1(sub(:,4),sub(:,2),d2);
            mdj(j)=md;
            md2j(j)=md2;
            mc(j)=match{j}(mci(mi1_less),1);
            
            speed(j)=(md2-md)/(d2-d);
            mcij=find(hole{j}(:,1)==mc(j));
            x=[md:(md2-md)/20:md2];
            try
                my(j,:)=interp1(hole{j}(mcij,2),hole{j}(mcij,3),x);
            end
            mcmin=min(hole{j}(mcij,2));
            mcmax=max(hole{j}(mcij,2));
            if(md-mcmin<1)
                edge(j)=-1;
            elseif(mcmax-md2 < 1)
                edge(j)=1;
            end
            f(j)=(md-mcmin)/(mcmax-mcmin);
            score(j)=(f(j)-.5)^2;    
        end
    end  
    
    choices=find(valid==1 & edge==0);
    if(isempty(choices))
        %d
        choices=find(valid==1);
        if(~isempty(choices))
            choice=choices(find(score(choices)==min(score(choices))));
        else
            choice=1;
        end
    elseif(max(size(choices))>2)
        choices=find(valid==1);
        spch=find(speed(choices)<1.5 & speed(choices)>.67);
        if(max(size(spch))<2)
            spch=find(speed(choices)>=1.5);
            if(max(size(spch))<2)
                spch=find(speed(choices)<=.67);
                if(max(size(spch))<2)
                    spch=find(speed(choices)<1.5 & speed(choices)>.67);
                end  
            end  
        end  
        choices=choices(spch);
        if(max(size(choices))>2)
            cmax=-1;
            for j=1:max(size(choices))-1
                for k=j+1:max(size(choices))
                    temp=corrcoef(my(choices(j),:),my(choices(k),:));
                    if(temp(1,2)>cmax)
                        cmax=temp(1,2);
                        cc=[j k];
                    end
                end
            end
            choices=choices(cc);
        end
        if(~isempty(choices))
            choice=find(score==min(score(choices)));
        else
            disp('Error in selecting choice')
        end
    else
        choice=find(score==min(score(choices)));
    end
    
    if(isempty(choice))
        disp('Error: No valid choice')
    end
    comp(end+1,1)=choice(1);
    comp(end,2)=mc(choice(1));
    comp(end,3)=mdj(choice(1));
    comp(end,4)=md2j(choice(1));
    comp(end,5)=d;
    comp(end,6)=d2;
    comp(end,7)=new_hole;
    
    d=d+step;
end

if(comp(1,1)~=1)
    comp(1,3)=min(hole{comp(1,1)}(:,2));
    comp(1,5)=comp(1,3);
end

%comp
%disp('Finished comp')

axes(handles.axes1)
cla
set(gca,'DefaulttextButtonDownFcn','autocomp(''text_ButtondownFcn'',gcbo,[],guidata(gcbo))');

offset=2.7*std(hole{1}(:,3));
for j=1:num
    if(round(j/2)==j/2)
        gr=.5;
    else
        gr=0;
    end
    color(j,:)=[0 gr (j-1)/(num-1)];
    c=mhole{j};
    plot(c(:,3)+(j-1)*offset,c(:,2),'Color',color(j,:));
    hold on;
    pc=match{j}(1,1);
    for k=1:max(size(match{j}(:,1)))
        if(match{j}(k,1)~=pc)
            ind=max(find(mhole{j}(:,2)<=match{j}(k,4)));
            plot(mhole{j}(ind,3)+(j-1)*offset, mhole{j}(ind,2),'o','Color',color(j,:));
            pc=match{j}(k,1);
        end
    end
end

set(gca,'DefaulttextButtonDownFcn','autocomp(''text_ButtondownFcn'',gcbo,[],guidata(gcbo))');
j=1;
cnt=1;
section=[];
while(j<=max(size(comp)))
    for k=j:max(size(comp))
        if(comp(j,1)~=comp(k,1))
            break;
        end 
    end
    if(k~=max(size(comp)))
        k=k-1;
    end
    h=comp(j,1);
    ind=find(mhole{h}(:,2)>=comp(j,5) & mhole{h}(:,2)<=comp(k,6));
    section(end+1,:)=[cnt j k];
    plot(mhole{h}(ind,3)+(h-1)*offset,mhole{h}(ind,2),'r');
    plot([0 (num+2.1)*offset],[mhole{h}(ind(1),2) mhole{h}(ind(1),2)],'k:');
    text((num+1.85)*offset,mhole{h}(ind(1),2),num2str(cnt),'FontSize',7,'VerticalAlignment','top');
    cnt=cnt+1;
    j=k+1;
end

%comp(1:10,:)

handles.offset=offset;
handles.comp=comp;
handles.color=color;
handles.section=section;
guidata(gcbo, handles);

ylim([0 40])
xlim([0 (num+2.1)*offset])
maxv=max(hole{1}(:,2));
set(handles.slider1,'min',0,'max',maxv,'Value',maxv,'sliderstep',[0.04 0.1]);

axis ij;

update_Callback(h, eventdata, handles, varargin)



% --------------------------------------------------------------------
function varargout = update_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.update.

handles=guidata(handles.figure1);
comp=handles.comp;

hole{1}=load(get(handles.sig1,'String'));
for i=2:4
    sig=['get(handles.sig' num2str(i) ',''String'')'];
    if(isempty(eval(sig)))
        break;
    end
    hole{end+1}=load(eval(sig),'-ASCII');
end
num=max(size(hole));


table=[];
j=1;
while(j<=max(size(comp)))
    for k=j:max(size(comp))
        if(comp(j,1)~=comp(k,1) | comp(j,2)~=comp(k,2))
            break;
        end 
    end
    if(k~=max(size(comp)) & k>1)
        k=k-1;
    end
    table(end+1,:)=[comp(j,1:3) comp(k,4) 999 999];
    j=k+1;
end

i=1;
cd=[];
tp=[];
stretch=[];
while(i<=max(size(comp(:,1))))
    %i
    if(i<max(size(comp(:,1))))
        compi=find(comp(i+1:end,7)==1);
        if(isempty(compi))
            compi=[i:max(size(comp(:,1)))];
            m=max(size(compi))+1;
        else
            m=min(compi);
            compi=[i:i+min(compi)-1];
        end
    else
        compi=[i];
        m=2;
    end
    i=i+m;
    
    j=1;
    d=[];
    y=[];
    short=0;
    while(j<=max(size(compi)))
        for k=j:max(size(compi))
            if(comp(compi(j),1)~=comp(compi(k),1))
                break;
            end 
        end
        if((k~=max(size(compi)) | comp(compi(j),1)~=comp(compi(end),1)) &k>1)
            k=k-1;
        end
        h=comp(compi(j),1);
        hind=find(hole{h}(:,2)>=min(comp(compi(j:k),3)) & ...
            hole{h}(:,2)<=max(comp(compi(j:k),4)) & ...
            hole{h}(:,1)==comp(compi(j),2));
        if(~isempty(hind))
            if(isempty(d))
                x=hole{h}(hind(1),2);
            else
                x=d(end)+.01;
            end
            %x
            d(end+1:end+max(size(hind)))=hole{h}(hind,2)-hole{h}(hind(1),2)+x;
            y(end+1:end+max(size(hind)))=hole{h}(hind,3);
            tp(end+1,:)=[comp(compi(j),2), hole{h}(hind(1),2), ...
                    x-hole{h}(hind(1),2), comp(compi(j),1) comp(compi(j),3)];
            tp(end+1,:)=[comp(compi(j),2), hole{h}(hind(end),2), ...
                    x-hole{h}(hind(1),2), comp(compi(j),1) comp(compi(k),4)];
            %[hole{h}(hind(end),2) comp(compi(k),4)]
        else
%             short=1;
%             last=comp(compi(j),5)
            break
        end
        j=k+1;
        if(j>max(size(compi)) & h==1 & hole{h}(hind(end),2)<comp(compi(k),5))
            short=1;
            last=hole{h}(hind(end),2);
        end
    end
    
    if(~isempty(d))
        if(short==1)
            newd=interp1([d(1) d(end)], [comp(compi(1),5) last], d);
            stretch(end+1)=(d(end)-d(1))/(last-comp(compi(1),5));
            newtp=interp1([d(1) d(end)], ...
                [comp(compi(1),5) last], ...
                tp(:,2)+tp(:,3));
            %newtp(end)
        else
            newd=interp1([d(1) d(end)], [comp(compi(1),5) comp(compi(end),6)-.01], d);
            stretch(end+1)=(d(end)-d(1))/(comp(compi(end),6)-comp(compi(1),5));
            newtp=interp1([d(1) d(end)], ...
                [comp(compi(1),5) comp(compi(end),6)-.01], ...
                tp(:,2)+tp(:,3));
        end
        cd(end+1:end+max(size(newd)),:)=[newd' y'];
        
        for f=1:size(tp)
            if(~isnan(newtp(f)))
                nf=tp(f,4);
                if(nf==1)
                    ind=find(table(:,1)==nf & table(:,3)==tp(f,5));
                else
                    ind=find(table(:,1)==nf & table(:,3)==tp(f,5) & table(:,5)==999);
                end
                if(~isempty(ind))
                    table(ind,5)=newtp(f);
                end
                ind=find(table(:,1)==nf & table(:,4)==tp(f,5) & table(:,6)==999);
                if(~isempty(ind))
                    table(ind,6)=newtp(f);
                end
            end
        end
    end
end

%mean(stretch)
%10^mean(log10(stretch))

for i=1:max(size(table(:,1)))
    ind=find(hole{table(i,1)}(:,1)==table(i,2));
    if(max(hole{table(i,1)}(ind,2))<table(i,4))
        table(i,4)=max(hole{table(i,1)}(ind,2));
        %table(i,:)
    end
end

handles.table=table;
handles.cds=cd;
guidata(gcbo, handles);

axes(handles.axes2);
cla
plot(cd(:,2),cd(:,1));
ylim(ylim(handles.axes1))
axis ij
hold on

% --------------------------------------------------------------------
function varargout = step_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.load.


% --------------------------------------------------------------------
function varargout = load_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.load.
name=get(handles.cdsname,'String');
comp=load([name '.comp']);
a=textread([name '.files'],'%s');
n=find(strcmp(a,'step'));
if(isempty(n))
    disp('Error: could not read file')
    break
end
i=1;
h=0;
label=0;
while(i<n)
    h=h+1;
    if(max(size(a{i}))==1)
        sig=['set(handles.name' num2str(h) ',''String'',a{i})'];
        eval(sig);
        i=i+1;
        label=1;
    end
    s=['handles.sig' num2str(h)];
    set(eval(s),'String',a{i});
    hole{h}=load(a{i},'-ASCII');
    i=i+1;
    if(h>1)
        s=['handles.msig' num2str(h)];
        set(eval(s),'String',a{i});
        mhole{h}=load(a{i},'-ASCII');
        i=i+1;
        s=['handles.match' num2str(h)];
        set(eval(s),'String',a{i});
        match{h}=load(a{i},'-ASCII');
        i=i+1;
    else
        mhole{1}=hole{1};
        match{1}=[hole{1}(:,1:2) hole{1}(:,1:2)];
    end
end
num=h;
if(num<4)
    for i=num+1:4
        s=['handles.name' num2str(i)];
        set(eval(s),'String','');
        s=['handles.sig' num2str(i)];
        set(eval(s),'String','');
        s=['handles.msig' num2str(i)];
        set(eval(s),'String','');
        s=['handles.match' num2str(i)];
        set(eval(s),'String','');
    end
end
set(handles.step,'String',a{n+1});

axes(handles.axes1)
cla
set(gca,'DefaulttextButtonDownFcn','autocomp(''text_ButtondownFcn'',gcbo,[],guidata(gcbo))');

offset=2.7*std(hole{1}(:,3));
for j=1:num
    if(round(j/2)==j/2)
        gr=.5;
    else
        gr=0;
    end
    color(j,:)=[0 gr (j-1)/(num-1)];
    c=mhole{j};
    plot(c(:,3)+(j-1)*offset,c(:,2),'Color',color(j,:));
    hold on;
    pc=match{j}(1,1);
    for k=1:max(size(match{j}(:,1)))
        if(match{j}(k,1)~=pc)
            ind=max(find(mhole{j}(:,2)<=match{j}(k,4)));
            plot(mhole{j}(ind,3)+(j-1)*offset, mhole{j}(ind,2),'o','Color',color(j,:));
            pc=match{j}(k,1);
        end
    end
end

set(gca,'DefaulttextButtonDownFcn','autocomp(''text_ButtondownFcn'',gcbo,[],guidata(gcbo))');
j=1;
cnt=1;
section=[];
while(j<=max(size(comp)))
  for k=j:max(size(comp))
    if(comp(j,1)~=comp(k,1))
      break;
    end 
  end
  if(k~=max(size(comp)))
    k=k-1;
  end
  h=comp(j,1);
  ind=find(mhole{h}(:,2)>=comp(j,5) & mhole{h}(:,2)<=comp(k,6));
  section(end+1,:)=[cnt j k];
  plot(mhole{h}(ind,3)+(h-1)*offset,mhole{h}(ind,2),'r');
  plot([0 (num+2.1)*offset],[mhole{h}(ind(1),2) mhole{h}(ind(1),2)],'k:');
  text((num+1.85)*offset,mhole{h}(ind(1),2),num2str(cnt),'FontSize',7,'VerticalAlignment','top');
  cnt=cnt+1;
  j=k+1;
end
handles.offset=offset;
handles.color=color;
handles.comp=comp;
handles.section=section;
guidata(gcbo, handles);

ylim([0 40])
xlim([0 (num+2.1)*offset])
axis ij;
maxv=max(hole{1}(:,2));
set(handles.slider1,'min',0,'max',maxv,'Value',maxv,'sliderstep',[0.04 0.1]);

update_Callback(h, eventdata, handles, varargin)

% --------------------------------------------------------------------
function varargout = save_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.save.
hole{1}=load(get(handles.sig1,'String'));
mhole{1}=hole{1};
match{1}=hole{1};
match{1}(:,3:4)=match{1}(:,1:2);
for i=2:4
    sig=['get(handles.sig' num2str(i) ',''String'')'];
    if(isempty(eval(sig)))
        break;
    end
    hole{end+1}=load(eval(sig),'-ASCII');
    msig=['get(handles.msig' num2str(i) ',''String'')'];
    mhole{end+1}=load(eval(msig),'-ASCII');
    m=['get(handles.match' num2str(i) ',''String'')'];
    match{end+1}=load(eval(m),'-ASCII');
end
num=max(size(hole));

comp=handles.comp;
name=get(handles.cdsname,'String');
save([name '.comp'],'comp','-ASCII');

fc=[name,'.files'];
fid=fopen(fc,'w');

c=get(handles.name1,'String');
if(~isempty(c))
    fprintf(fid,'%c\n',c(1));
    h(1)=c;
else
    h(1)=num2str(i);
end
fprintf(fid,'%s\n',get(handles.sig1,'String'));
signal{1}=get(handles.sig1,'String');
for i=2:4
    sig=['get(handles.name' num2str(i) ',''String'')'];
    c=eval(sig);
    if(~isempty(c))
        fprintf(fid,'%c\n',c(1));
        h(i)=c;
    else
        h(i)=num2str(i);
    end
    sig=['get(handles.sig' num2str(i) ',''String'')'];
    fprintf(fid,'%s\n',eval(sig));
    signal{i}=eval(sig);
    sig=['get(handles.msig' num2str(i) ',''String'')'];
    fprintf(fid,'%s\n',eval(sig));
    sig=['get(handles.match' num2str(i) ',''String'')'];
    fprintf(fid,'%s\n',eval(sig));
end

fprintf(fid,'step %s\n',get(handles.step,'String'));
fclose(fid);

table=handles.table;

ind=find(table(:,5)==999 & table(:,6)==999);
if(~isempty(ind))
    %table(ind,:)
    ind2=find(table(ind,4)<table(ind,3));
    if(~isempty(ind2))
            table(ind(ind2),:)=[];
%          for i=1:max(size(ind2))
%              table(ind(ind2(end-i+1)),:)=[];
%          end
    end
end
ind=find(table(:,5)==999 & table(:,6)==999);
if(~isempty(ind))
    %table(ind,:)
    table(ind,5)=table(ind-1,6)+.001;
    table(ind,6)=table(ind+1,5)-.001;
end
    
for j=5:6
    ind=find(table(:,j)==999 & table(:,1)==1);
    if(~isempty(ind))
        table(ind,j)=table(ind,j-2);
        %table(ind(1)-1:ind(end),:)
    end
end
ind=find(table(:,5)==999 & table(:,4)<=table(:,3));
if(~isempty(ind))
    ind2=find(table(ind-1,6)==999);
    if(~isempty(ind2))
        table(ind(ind2)-1,6)=table(ind(ind2),6);
        %table(ind(ind2)-1,:)
        table(ind(ind2),:)=[];
    end
end
ind=find(table(:,5)==999 & table(:,6)==999 & table(:,3)>=.997*table(:,4));
if(~isempty(ind))
    table(ind,:)=[];
end

ind=find(table(:,4)<table(:,3));
if(~isempty(ind))
    %table(ind,:)
    table(ind,:)=[];
end

if(~isempty(find(table(:,5)==999 | table(:,6)==999)))
    disp('Warning: Table for composite section construction contains invalid values denoted 999.')
end

fc=[name,'.section'];
fid=fopen(fc,'w');
fprintf(fid,'Hole Core Start(mbsf) End(mbsf) Start(nmcd) End(nmcd)\n');
for j=1:max(size(table))
    fprintf(fid,'%4c %4d %11.4f %9.4f %11.4f %9.4f\n',h(table(j,1)), table(j,2:6));
end
fclose(fid);

cds=handles.cds;
save([name '.cds'],'cds','-ASCII');

newh=hole{1};
for i=1:max(size(table(:,1)))
%for i=1:35
    t=table(i,:);
    ind=find(match{t(1)}(:,1)==t(2) & match{t(1)}(:,2)>=t(3) & match{t(1)}(:,2)<=t(4));
    if(isempty(ind))
        ind=find(match{t(1)}(:,1)==t(2) & match{t(1)}(:,2)>=t(3));
        if(isempty(ind))
            disp('Error generating mcd for target')
            table(i-1:i+1,:)
            break
        end
        ind=ind(1);
    end
    for j=1:max(size(ind))
        if(j==1 & ind(j)~=1)
            mh=match{t(1)}(ind(j)-1:ind(j),:);
            if(mh(1,3)==mh(2,3))
                jnd=find(newh(:,1)==mh(1,3) & newh(:,2)>=mh(1,4) & newh(:,2)<=mh(2,4));
                ix=interp1(mh(:,4),mh(:,2),newh(jnd,2));
                k=find(newh(jnd,4)==0 | isnan(newh(jnd,4)));
                newh(jnd(k),4)=interp1(t(3:4),t(5:6),ix(k));
            end
        end
        if(ind(j)<max(size(match{t(1)}(:,1))))
            mh=match{t(1)}(ind(j):ind(j)+1,:);
            if(mh(1,3)==mh(2,3))
                jnd=find(newh(:,1)==mh(1,3) & newh(:,2)>=mh(1,4) & newh(:,2)<=mh(2,4));
                ix=interp1(mh(:,4),mh(:,2),newh(jnd,2));
                newh(jnd,4)=interp1(t(3:4),t(5:6),ix);
            end
        end
        %if(i<9 & t(1)~=1)
            %mh
        %end
    end
end
ind=find(newh(:,4)==0 | isnan(newh(:,4)));
newh(ind,4)=newh(ind,2);
%save('testmcd','newh','-ASCII');

mcd=newh(:,[4 3]);
%newh(:,5)=newh(:,3);
%newh(:,1:3)=[];
[p,n,e,v]=fileparts(signal{1});
save([n '.mcd'],'mcd','-ASCII');

for i=2:num
    tp{i}=[];
    for c=match{i}(1,1):match{i}(end,1)
        ind=find(match{i}(:,1)==c);
        ind2=find(hole{i}(:,1)==c);
        if(isempty(ind))
            continue
        end
        jnd=min(find(newh(:,1)==match{i}(ind(1),3) & newh(:,2)>=match{i}(ind(1),4)));
        if(~isempty(jnd) & jnd~=1)
            if(newh(jnd-1,1)==newh(jnd,1))
                if(match{i}(ind(1),2)>=min(hole{i}(ind2,2)))
                    newx=interp1(newh(jnd-1:jnd,2),newh(jnd-1:jnd,4),match{i}(ind(1),4));
                    if(~isnan(newx))
                        tp{i}(end+1,:)=[match{i}(ind(1),1:2) 0 newx];
                    end
                end
            end
        end
        for j=1:3
            k=round(j/3*max(size(ind)));
            if(k>1 & match{i}(ind(k),2)>max(hole{i}(find(hole{i}(:,1)==c))))
                k=k-1;
            end
            jnd=min(find(newh(:,1)==match{i}(ind(k),3) & newh(:,2)>=match{i}(ind(k),4)));
            if(~isempty(jnd) & jnd~=1)
                if(newh(jnd-1,1)==newh(jnd,1))
                    newx=interp1(newh(jnd-1:jnd,2),newh(jnd-1:jnd,4),match{i}(ind(k),4));
                    if(~isnan(newx))
                        tp{i}(end+1,:)=[match{i}(ind(k),1:2) 0 newx];
                    end
                end
            end
        end
    end
    t=tp{i};
    [p,n,e,v]=fileparts(signal{i});
    save([n '.mcd.tie'],'t','-ASCII');
end


% --------------------------------------------------------------------
function varargout = edit_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.edit.

% --------------------------------------------------------------------
function varargout = exit_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.edit.
% Quit program (graphical user interface, autocomp)
delete(handles.figure1);

% --------------------------------------------------------------------
function varargout = delete_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.delete.
if(get(handles.edit,'Value')==1)
    n=str2num(get(handles.delete,'String'));
    if(n==1)
        disp('Cannot delete first section')
        break
    end
    comp=handles.comp;
    section=handles.section;
    %size(section)
    ni=find(section(:,1)==n);
    if(isempty(ni))
        s=['Error: Section ' num2str(n) ' does not exist.'];
        disp(s);
        break
    end
    a=section(ni,2);
    b=section(ni,3);
    %comp(a-1:b+1,:)
    %section(ni-1:ni+2,:)
    ind=[a:b];
    i=comp(a-1,1);
    oldi=comp(a,1);
    targ=load(get(handles.sig1,'String'));
    if(i==1)
        %hole=targ;
        mhole=targ;
        match=[targ(:,1:2) targ(:,1:2)];
    else
        sig=['get(handles.sig' num2str(i) ',''String'')'];
        msig=['get(handles.msig' num2str(i) ',''String'')'];
        m=['get(handles.match' num2str(i) ',''String'')'];
        %hole=load(eval(sig),'-ASCII');
        mhole=load(eval(msig),'-ASCII');
        match=load(eval(m),'-ASCII');
    end
    if(oldi==1)
        omhole=targ;
    else
        msig=['get(handles.msig' num2str(oldi) ',''String'')'];
        omhole=load(eval(msig),'-ASCII');
    end

    newline=[];
    if(~isempty(ind))
        for j=1:max(size(ind))
            d=comp(ind(j),5);           
            d2=comp(ind(j),6);
            k=min(find(targ(:,2)>=d));
            c1=targ(k,1);
            c2=c1+1;
            %******************* DOES NOT WORK RIGHT IF HOLE CONTAINS GAP *********************
            mci=find(match(:,3)>=c1-1 & match(:,3)<=c2+2);
            mi1_less=max(find(match(mci,4)<=d & match(mci,3)==c1));
            if(isempty(mi1_less))
                mi1_less=max(find(match(mci,4)<=d));
            end
            mc=match(mci(mi1_less),1);
            mi1_more=min(find(match(mci,4)>d & match(mci,1)==mc));
            mi2_less=max(find(match(mci,4)<=d2 & match(mci,1)==mc));
            mi2_more=min(find(match(mci,4)>d2 & match(mci,1)==mc));
            if(isempty(mi1_more)| mi1_more<=mi1_less)
                mi1_more=min(find(match(mci,4)>d & mci>mi1_less));
            end
            if(isempty(mi2_less))
                mi2_less=max(find(match(mci,4)<=d2));
            end
            if(isempty(mi2_more) | mi2_more<=mi2_less)
                mi2_more=min(find(match(mci,4)>=d2 & mci>mi2_less));               
            end
            %[c1 c2]
            %[mi1_less mi1_more mi2_less mi2_more]
            %mci(mi1_less)
            sub=match(mci(mi1_less:mi1_more),:);
            md=interp1(sub(:,4),sub(:,2),d);
            sub=match(mci(mi2_less:mi2_more),:);
            md2=interp1(sub(:,4),sub(:,2),d2);
            comp(ind(j),1:6)=[i mc md md2 d d2];
        end
    end
    %section(ni-1:ni+1,:)
    section(ni-1,3)=section(ni,3);
    section(ni,:)=[];
    %comp(a-1:b+1,:)
    %disp('deleted:')
    %section(ni-1:end,:)
    handles.comp=comp;
    handles.section=section;
    guidata(gcbo, handles);
   
    hobj1=findobj('String',num2str(n),'Parent',handles.axes1,'Color','k');
    x=get(hobj1,'Position');
    delete(hobj1);
    delete(findobj('YData',[x(2) x(2)],'Parent',handles.axes1));
    axes(handles.axes1)
    hold on;
    ind=find(omhole(:,2)>=comp(a,5) & omhole(:,2)<=comp(b,6));
    color=handles.color;
    plot(omhole(ind,3)+(oldi-1)*handles.offset,omhole(ind,2),'Color',color(oldi,:));
    ind=find(mhole(:,2)>=comp(a,5) & mhole(:,2)<=comp(b,6));
    plot(mhole(ind,3)+(i-1)*handles.offset,mhole(ind,2),'r');

end

% --------------------------------------------------------------------
function varargout = insert_Callback(h, eventdata, handles, varargin)
% Stub for Callback of the uicontrol handles.insert.
if(get(handles.edit,'Value')==1)
    n=str2num(get(handles.insert,'String'));
    comp=handles.comp;
    section=handles.section;
    ni=find(section(:,1)==n);
    if(isempty(ni))
        s=['Error: Section ' num2str(n) ' does not exist.'];
        disp(s);
        break
    end
    a=section(ni,2);
    b=section(ni,3);
    step=str2num(get(handles.step,'String'));
    if(comp(b,6)-comp(a,5)<=step)
        s=['Error: Section ' num2str(n) ' is too small to subdivide.'];
        disp(s);
        break
    end

    %comp(a-1:b+1,:)
    %section(ni-1:ni+2,:)
    d=comp(a,5);         
    d2=comp(a,5)+step;
    if(comp(a,6)~=d2)
        i=comp(a,1);
        targ=load(get(handles.sig1,'String'));
        if(i==1)
            mhole=targ;
            match=[targ(:,1:2) targ(:,1:2)];
        else
            msig=['get(handles.msig' num2str(i) ',''String'')'];
            m=['get(handles.match' num2str(i) ',''String'')'];
            mhole=load(eval(msig),'-ASCII');
            match=load(eval(m),'-ASCII');
        end
        k=max(find(targ(:,2)<=d2));
        c2=comp(a,2);
        c1=c2;
        mci=find(match(:,1)==c2+1 | match(:,1)==c2);
        mi2_less=max(find(match(mci,4)<=d2 & match(mci,1)==c2));
        mi2_more=min(find(match(mci,4)>d2 & match(mci,1)==c2));
        new=0;
        if(isempty(mi2_less))
            mi2_less=max(find(match(mci,4)<=d2));
            c2=match(mci(mi2_less),1);
            new=1;
        end
        if(isempty(mi2_more) | mi2_more<=mi2_less)
            mi2_more=min(find(match(mci,4)>=d2 & mci>mi2_less));
        end
        sub=match(mci(mi2_less:mi2_more),:);
        md2=interp1(sub(:,4),sub(:,2),d2);
        newline1=[i c1 comp(a,3) md2 comp(a,5) d2 comp(a,7)];
        newline2=[i c2 md2 comp(a,4) d2 comp(a,6) new];
        
        %newline
        comp(a+2:end+1,:)=comp(a+1:end,:);
        comp(a,:)=newline1;
        comp(a+1,:)=newline2;
        section(ni+2:end+1,:)=[section(ni+1:end,1) section(ni+1:end,2:3)+1];
        newn=max(section(:,1))+1;
        section(ni+1,:)=[newn a+1 b+1];
        section(ni,:)=[n a a];
        %comp(a-1:b+2,:)
        %section(ni-1:ni+2,:)
        handles.comp=comp;
    else
        section(ni+2:end+1,:)=[section(ni+1:end,1) section(ni+1:end,2:3)];
        newn=max(section(:,1))+1;
        section(ni+1,:)=[newn a+1 b];
        section(ni,:)=[n a a];
        %disp('inserted')
        %section(ni-1:ni+2,:)
    end
    handles.section=section;
    guidata(gcbo, handles);
    axes(handles.axes1);
    x=xlim(handles.axes1);
    hold on;
    plot([0 x(2)],[d2 d2],'k:');
    text(.936*x(2),d2,num2str(newn),'FontSize',7,'VerticalAlignment','top');
end

% --------------------------------------------------------------------
% Move section boundary or change its reference hole
function varargout = text_ButtondownFcn(h, eventdata, handles, varargin)

num=str2num(get(gcbo,'String'));
if(get(handles.edit,'Value')==1)
    targ=load(get(handles.sig1,'String'));
    hole{1}=targ;
    mhole{1}=hole{1};
    match{1}=hole{1};
    match{1}(:,3:4)=match{1}(:,1:2);
    maxi=2;
    for i=2:4
        sig=['get(handles.sig' num2str(i) ',''String'')'];
        if(~isempty(eval(sig)))
            maxi=i;
        else
            break;
        end
        msig=['get(handles.msig' num2str(i) ',''String'')'];
        m=['get(handles.match' num2str(i) ',''String'')'];
        hole{end+1}=load(eval(sig),'-ASCII');
        mhole{end+1}=load(eval(msig),'-ASCII');
        match{end+1}=load(eval(m),'-ASCII');
    end
    offset=handles.offset;  
    section=handles.section;
    comp=handles.comp;    
    ni=find(section(:,1)==num);
    a=section(ni,2);
    b=section(ni,3);
    oldi=comp(a,1);
    
    [x1,y1]=ginput(1);
    axes(handles.axes1)
    hold on;
    
    xx=xlim(handles.axes1);
    if(x1>.93*(xx(2)-xx(1))+xx(1))
        newi=oldi;
    else
        dist=[];
        for i=1:maxi
            ind=find(mhole{i}(:,2)>=.9*comp(a-1,5) & mhole{i}(:,2)<=1.1*comp(b,6));
            m=mean(mhole{i}(ind,3))+(i-1)*offset;
            dist(i)=abs(x1-m);
        end
        newi=find(dist==min(dist));
    end
    ind=[];
    if(newi==oldi)
        a1=section(ni-1,2);
        b1=section(ni-1,3);
        newd=y1;
        if(newd<=comp(a1,5) | newd>=comp(b,6))
            disp('Error: Cannot cross section boundaries')
            comp(a1:b+1,:)
            section(ni-1:ni+2,:)
            break
        end
        x=get(gcbo,'Position');
        oldd=x(2);
        newx=x;
        newx(2)=newd;
        set(gcbo,'Position',newx);
        delete(findobj('YData',[x(2) x(2)],'Parent',handles.axes1));
        x2=xlim(handles.axes1);
        plot([0 x2(2)],[newd newd],'k:');
        
        if(newd<comp(a,5))
            h2=comp(a-1,1);
            h=newi;
            ind1=[a1:b1];
            ii=find(comp(ind1,6)>=newd);
            ind=ind1(ii);
            comp(ind(1),6)=newd;
            comp(ind(1)+1,5)=newd;
            c1=comp(ind(1),2);
            mci=find(match{h2}(:,1)>= c1-1 | match{h2}(:,1)<=c1+1);
            mi2_less=max(find(match{h2}(mci,4)<=newd & match{h2}(mci,3)==c1));
            mi2_more=min(find(match{h2}(mci,4)>newd & match{h2}(mci,3)==c1));
            if(isempty(mi2_less))
                mi2_less=max(find(match{h2}(mci,4)<=newd));
            end
            if(isempty(mi2_more) | mi2_more<=mi2_less)
                mi2_more=min(find(match{h2}(mci,4)>=newd & mci>mi2_less));
            end
            sub=match{h2}(mci(mi2_less:mi2_more),:);
            md2=interp1(sub(:,4),sub(:,2),newd);
            comp(ind(1),4)=md2;
            section(ni-1,3)=ind(1);
            section(ni,2)=ind(1)+1;
            ind2=ind;
            ind=ind(2:end);
        elseif (newd>comp(a,5))
            h=comp(a-1,1);
            h2=newi;
            ind1=[a:b];
            ii=find(comp(ind1,6)>=newd);
            ind=ind1(ii);
            %ind=ind1(find(comp(ind1,5)<=newd));
            comp(ind(end)-1,6)=newd;
            comp(ind(end),5)=newd;
            c1=comp(ind(end),2);
            mci=find(match{h2}(:,1)>= c1-1 | match{h2}(:,1)<=c1+1);
            mi2_less=max(find(match{h2}(mci,4)<=newd & match{h2}(mci,3)==c1));
            mi2_more=min(find(match{h2}(mci,4)>newd & match{h2}(mci,3)==c1));
            if(isempty(mi2_less))
                mi2_less=max(find(match{h2}(mci,4)<=newd));
            end
            if(isempty(mi2_more) | mi2_more<=mi2_less)
                mi2_more=min(find(match{h2}(mci,4)>=newd & mci>mi2_less ));
            end
            sub=match{h2}(mci(mi2_less:mi2_more),:);
            md=interp1(sub(:,4),sub(:,2),newd);
            comp(ind(end),3)=md;
            section(ni-1,3)=ind(end)-1;
            section(ni,2)=ind(end);
            ind2=ind;
            ind=ind(1:end-1);
        end
    else
        ind=[a:b];  
        ind2=ind;
        h=newi;
        h2=oldi;
        newd=comp(a,5);
        oldd=comp(b,6);
    end
    %disp('handled boundary case')
    if(~isempty(ind))
        for j=1:max(size(ind))
            d=comp(ind(j),5);           
            d2=comp(ind(j),6);
            k=min(find(targ(:,2)>=d));
            c1=targ(k,1);
            c2=c1+1;
            %******************* DOES NOT WORK RIGHT IF HOLE CONTAINS GAP *********************
            mci=find(match{h}(:,3)>=c1-1 | match{h}(:,3)<=c2+1);
            mi1_less=max(find(match{h}(mci,4)<=d & match{h}(mci,3)==c1));
            if(isempty(mi1_less))
                mi1_less=max(find(match{h}(mci,4)<=d));
            end
            mc=match{h}(mci(mi1_less),1);
            mi1_more=min(find(match{h}(mci,4)>d & match{h}(mci,1)==mc));
            mi2_less=max(find(match{h}(mci,4)<=d2 & match{h}(mci,1)==mc));
            mi2_more=min(find(match{h}(mci,4)>d2 & match{h}(mci,1)==mc));
            if(isempty(mi1_more)| mi1_more<=mi1_less)
                mi1_more=min(find(match{h}(mci,4)>d & mci>mi1_less));
            end
            if(isempty(mi2_less))
                mi2_less=max(find(match{h}(mci,4)<=d2));
            end
            if(isempty(mi2_more) | mi2_more<=mi2_less)
                mi2_more=min(find(match{h}(mci,4)>=d2 & mci>mi2_less));
            end
            sub=match{h}(mci(mi1_less:mi1_more),:);
            md=interp1(sub(:,4),sub(:,2),d);
            sub=match{h}(mci(mi2_less:mi2_more),:);
            md2=interp1(sub(:,4),sub(:,2),d2);
            comp(ind(j),1:6)=[h mc md md2 d d2];
        end
    end
    %comp(ind,:)
    handles.comp=comp;
    handles.section=section;
    guidata(gcbo, handles);
   
    d1=min([newd oldd]);
    d2=max([newd oldd]);
    ind=find(mhole{h2}(:,2)>=d1 & mhole{h2}(:,2)<=d2);
    color=handles.color;
    plot(mhole{h2}(ind,3)+(h2-1)*handles.offset,mhole{h2}(ind,2),'Color',color(h2,:));
    ind=find(mhole{h}(:,2)>=d1 & mhole{h}(:,2)<=d2);
    plot(mhole{h}(ind,3)+(h-1)*handles.offset,mhole{h}(ind,2),'r');
    
end

@
